"""
File to build submaps for each scan in a dataset heuristically. The built subamps are saved as a numpy matrix.
anchor submaps are built using only the previous keyframes.
positive and negative submaps are built using all keyframes.
keyframe submaps are built using only keyframes.
Both anchor and pos_neg submaps are in all frames indices orders.
Keyframe submaps are in keyframes indices order.

!!!
Note, different with build_submaps.py, this script uses a heuristic method to build submaps. The keyframes are not
the keyframes generated by SLAM. Instead, the keyframes are generated by randomly selecting frame a certain time step
from current scan. The reason why we do not use the keyframes generated by SLAM is that these keyframes are always same
for all the scans. In another word, there is a large part of generated submaps share the same keyframes. Thus, in
training step, the model may learn how to maximize the portion of shared keyframes instead of learning the features of
the submaps. This is not what we want. So, we use a heuristic method to generate keyframes for each scan. The submaps
will not share the same keyframes. The model would learn how to match the subamps.
!!!
"""
import os
import yaml
import numpy as np
import matplotlib.pyplot as plt

from compute_submaps import compute_submap_keyframes, compute_keyframes_indices
from tools.fileloader import load_xyz_rot, load_overlaps


if __name__ == '__main__':
    config_path = '/home/vectr/PycharmProjects/lidar_learning/configs/config.yml'
    params_path = '/home/vectr/PycharmProjects/lidar_learning/configs/parameters.yml'

    config = yaml.safe_load(open(config_path))
    params = yaml.safe_load(open(params_path))

    frames_poses_folder = config['data_root']['poses']
    keyframes_poses_folder = config['data_root']['keyframes']
    overlaps_folder = config['data_root']['overlaps']
    submaps_folder = config['data_root']['submaps']

    sequences = config['seqs']['all']
    top_k = 5

    for sequence in sequences:
        frames_poses_path = os.path.join(frames_poses_folder, sequence, 'poses.txt')
        keyframes_poses_path = os.path.join(keyframes_poses_folder, sequence, 'poses', 'poses_kf.txt')
        overlaps_path = os.path.join(overlaps_folder, f'{sequence}.bin')

        # load the poses of the frames
        xyz, _ = load_xyz_rot(frames_poses_path)
        xyz_kf, _ = load_xyz_rot(keyframes_poses_path)
        overlaps = load_overlaps(overlaps_path)

        # compute the keyframes indices
        indices_kf = compute_keyframes_indices(xyz, xyz_kf)     # compute the indices of keyframes (in number of frames)

        # compute the submaps for all frames (in shape (n, top_k))
        submaps_euclidean_in_kf_order = compute_submap_keyframes(xyz, xyz_kf, overlaps, top_k=5,
                                                                 overlap_dist_thresh=25.0,
                                                                 is_anchor=False, metric='euclidean')
        submaps_overlap_in_kf_order = compute_submap_keyframes(xyz, xyz_kf, overlaps, top_k=5, overlap_dist_thresh=25.0,
                                                               is_anchor=False, metric='overlap')

        # compute the submaps for anchor (in shape (n, top_k)). Anchor submaps only consider the previous keyframes
        submaps_anchor_euclidean_in_kf_order = compute_submap_keyframes(xyz, xyz_kf, overlaps, top_k=5,
                                                                        overlap_dist_thresh=25.0,
                                                                        is_anchor=True, metric='euclidean')
        submaps_anchor_overlap_in_kf_order = compute_submap_keyframes(xyz, xyz_kf, overlaps, top_k=5,
                                                                      overlap_dist_thresh=25.0,
                                                                      is_anchor=True, metric='overlap')

        # transform the submaps indices from keyframes indices order to all frames indices order
        submaps_euclidean = np.array([indices_kf[submaps_euclidean_in_kf_order[i, :]] for i in
                                      range(len(submaps_euclidean_in_kf_order))])
        submaps_overlap = np.array([indices_kf[submaps_overlap_in_kf_order[i, :]] for i in
                                    range(len(submaps_overlap_in_kf_order))])

        submaps_anchor_euclidean = np.array([indices_kf[submaps_anchor_euclidean_in_kf_order[i, :]] for i in
                                             range(len(submaps_anchor_euclidean_in_kf_order))])
        submaps_anchor_overlap = np.array([indices_kf[submaps_anchor_overlap_in_kf_order[i, :]] for i in
                                           range(len(submaps_anchor_overlap_in_kf_order))])

        # compute the submaps for keyframes (in shape (m, 3)). indices are in keyframes list order.
        submaps_kf_euclidean = submaps_euclidean_in_kf_order[indices_kf, :]
        submaps_kf_overlap = submaps_overlap_in_kf_order[indices_kf, :]

        # add randomness for anchor and pos_neg submaps
        num_frames = len(overlaps)
        avg_keyframes_interval = np.mean(indices_kf[1:] - indices_kf[:-1])
        for i in range(num_frames):
            random_shift = (np.random.normal(0, 0.447, size=5) * avg_keyframes_interval / 2).astype(np.int32)
            selected_kfs_euclidean = submaps_euclidean[i, :]
            selected_kfs_overlap = submaps_overlap[i, :]
            selected_kfs_euclidean += random_shift
            selected_kfs_overlap += random_shift
            selected_kfs_euclidean = np.clip(selected_kfs_euclidean, 0, num_frames-1)
            selected_kfs_overlap = np.clip(selected_kfs_overlap, 0, num_frames-1)
            submaps_euclidean[i, :] = selected_kfs_euclidean
            submaps_overlap[i, :] = selected_kfs_overlap

        for i in range(num_frames):
            random_shift = (np.random.normal(0, 0.447, size=5) * avg_keyframes_interval / 2).astype(np.int32)
            selected_kfs_euclidean = submaps_anchor_euclidean[i, :]
            selected_kfs_overlap = submaps_anchor_overlap[i, :]

            sign_mask_euclidean_bool = selected_kfs_euclidean + random_shift > i
            sign_mask_euclidean = np.ones(len(sign_mask_euclidean_bool), dtype=np.int32)
            sign_mask_euclidean[sign_mask_euclidean_bool] = -1
            sign_mask_overlap_bool = selected_kfs_overlap + random_shift > i
            sign_mask_overlap = np.ones(len(sign_mask_overlap_bool), dtype=np.int32)
            sign_mask_overlap[sign_mask_overlap_bool] = -1

            selected_kfs_euclidean += random_shift * sign_mask_euclidean
            selected_kfs_overlap += random_shift * sign_mask_overlap
            selected_kfs_euclidean = np.clip(selected_kfs_euclidean, 0, i)
            selected_kfs_overlap = np.clip(selected_kfs_overlap, 0, i)

            submaps_anchor_euclidean[i, :] = selected_kfs_euclidean
            submaps_anchor_overlap[i, :] = selected_kfs_overlap

        # save the submaps
        submaps_euclidean_saving_path = os.path.join(submaps_folder, 'euclidean_heuristic', sequence)
        submaps_overlap_saving_path = os.path.join(submaps_folder, 'overlap_heuristic', sequence)

        if not os.path.exists(submaps_euclidean_saving_path):
            os.makedirs(submaps_euclidean_saving_path)
        if not os.path.exists(submaps_overlap_saving_path):
            os.makedirs(submaps_overlap_saving_path)

        np.save(os.path.join(submaps_euclidean_saving_path, 'anchor.npy'), submaps_anchor_euclidean)
        np.save(os.path.join(submaps_euclidean_saving_path, 'pos_neg.npy'), submaps_euclidean)
        np.save(os.path.join(submaps_euclidean_saving_path, 'kf.npy'), submaps_kf_euclidean)
        np.save(os.path.join(submaps_overlap_saving_path, 'anchor.npy'), submaps_anchor_overlap)
        np.save(os.path.join(submaps_overlap_saving_path, 'pos_neg.npy'), submaps_overlap)
        np.save(os.path.join(submaps_overlap_saving_path, 'kf.npy'), submaps_kf_overlap)
